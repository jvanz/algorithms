
#include <jvanz/linked_list.hpp>

namespace jvanz{

template<typename T>
LinkedList<T>::LinkedList()
{
	throw "Not implemented";
}

template<typename T>
LinkedList<T>::LinkedList(const LinkedList&)
{
	throw "Not implemented";
}

template<typename T>
LinkedList<T>::LinkedList(LinkedList&&)
{
	throw "Not implemented";
}

template<typename T>
LinkedList<T>& LinkedList<T>::operator=(const LinkedList&)
{
	throw "Not implemented";
}

template<typename T>
LinkedList<T>& LinkedList<T>::operator=(LinkedList&&)
{
	throw "Not implemented";
}

template<typename T>
LinkedList<T>::~LinkedList()
{
	throw "Not implemented";
}

template<typename T>
std::iterator_traits<T> LinkedList<T>::begin()
{
	throw "Not implemented";
}

template<typename T>
std::iterator_traits<T> LinkedList<T>::end()
{
	throw "Not implemented";
}

template<typename T>
std::iterator_traits<T> LinkedList<T>::cbegin()
{
	throw "Not implemented";
}

template<typename T>
std::iterator_traits<T> LinkedList<T>::cend()
{
	throw "Not implemented";
}

template<typename T>
bool LinkedList<T>::operator==(const LinkedList&)
{
	throw "Not implemented";
}

template<typename T>
bool LinkedList<T>::operator!=(const LinkedList&)
{
	throw "Not implemented";
}

template<typename T>
void LinkedList<T>::swap(unsigned int a, unsigned int b)
{
	throw "Not implemented";
}

template<typename T>
size_t LinkedList<T>::size()
{
	throw "Not implemented";
}

template<typename T>
size_t LinkedList<T>::max_size()
{
	throw "Not implemented";
}

template<typename T>
bool LinkedList<T>::empty()
{
	throw "Not implemented";
}

}; // namespace jvanz
